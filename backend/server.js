const express = require('express');
const mongoose = require('mongoose');
const { Parser } = require('json2csv');
const cors = require('cors');
require('dotenv').config();

const app = express();
app.use(cors());
// {
//   origin: 'http://localhost:3000' // Replace with your frontend URL
// }

app.use(express.json());

// Middleware
app.use((req, res, next) => {
    console.log(`[${new Date().toISOString()}] ${req.method} request to ${req.url}`);
    next(); // Pass the request to the next middleware/route handler
});

// Connect to MongoDB Atlas using the connection string from the .env file
mongoose.connect(process.env.MONGO_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
}).then(() => {
    console.log('Connected to MongoDB Atlas');
}).catch((error) => {
    console.error('Error connecting to MongoDB Atlas:', error);
});

// User schema
// const userSchema = new mongoose.Schema({
//     prolificId: {
//         type: String,
//         required: true,
//         unique: true // Ensure each ID is unique
//     },
//     startTime: {
//         type: Date,
//         default: Date.now // Automatically set to the current date/time
//     },
//     endTime: {
//         type: Date,
//         default: Date.now // This can be updated later
//     },
//     page: {
//         type: String,
//         default: ""
//     },
//     selectedOption: {
//         type: String,
//         default: ""
//     }
// });

// const User = mongoose.model('User', userSchema);

// Updated User schema
// const userSchema = new mongoose.Schema({
//   prolificId: {
//     type: String,
//     required: true,
//     unique: true
//   },
//   startTime: {
//     type: Date,
//     default: Date.now
//   },
//   endTime: {
//     type: Date,
//     default: Date.now
//   },
//   page: {
//     type: String,
//     default: ""
//   },
//   selectedOption: {
//     type: String,
//     default: ""
//   },
//   // New field to store an array of arrays (matrix) of selected fridges
//   fridgeSelectionMatrix: [
//     [
//       {
//         fridgeName: String,
//         selectTime: Date
//       }
//     ]
//   ]
// });

//updated userSchema with formData
const userSchema = new mongoose.Schema({
  prolificId: {
    type: String,
    required: true,
    unique: true,
  },
  startTime: {
    type: Date,
    default: Date.now,
  },
  endTime: {
    type: Date,
    default: Date.now,
  },
  page: {
    type: String,
    default: "",
  },
  selectedOption: {
    type: String,
    default: "",
  },
  // New field to store an array of arrays (matrix) of selected fridges
  fridgeSelectionMatrix: [
    [
      {
        fridgeName: String,
        fridgeNameId: String,
        selectTime: Date,
      },
    ],
  ],
  // New field to store survey responses
  formData: {
    type: Object,
    default: {},
  },
  startConditionClick: {
    type: [Date], // Array of dates for start condition clicks
    default: [],
  },
  comparisonClick: {
    type: [Date], // Array of dates for comparison clicks
    default: [],
  },
  selectFridgeClick: {
    type: [Date], // Array of dates
    default: [],
  },
  shuffledFridges: {
    type: [[String]], // Matrix to store arrays of fridge nameId strings
    default: [],
  },
});

const User = mongoose.model('User', userSchema);

// Route to get all users
app.get('/api/7427865484/users', async (req, res) => {
  try {
    const users = await User.find();
    res.json(users);
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});


// Route to get user by prolificId
app.get('/api/users/:prolificId', async (req, res) => {
  const { prolificId } = req.params;

  try {
    // Find the user by prolificId
    const user = await User.findOne({ prolificId });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json({ user });
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});


// User creation route
app.post('/api/users/create', async (req, res) => {
    const { prolificId } = req.body;

    try {
        // Check if user already exists
        let user = await User.findOne({ prolificId });

        if (!user) {
            // Create a new user if not found
            user = new User({ prolificId });
            await user.save();
        }

        res.status(201).json({ message: 'User created successfully', user });
    } catch (error) {
        console.error('Error creating user:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// User update route
app.patch('/api/users/update', async (req, res) => {
  const { prolificId, endTime, selectedOption } = req.body;

  try {
    const user = await User.findOneAndUpdate(
      { prolificId },
      { endTime, selectedOption },
      { new: true }
    );

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json({ message: 'User updated successfully', user });
  } catch (error) {
    console.error('Error updating user:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});


app.patch('/api/users/update-page', async (req, res) => {
    const { prolificId, page } = req.body;

    try {
        const user = await User.findOneAndUpdate(
            { prolificId },
            { page },
            { new: true }
        );

        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        res.status(200).json({ message: 'Page updated successfully', user });
    } catch (error) {
        console.error('Error updating page:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// app.patch('/api/users/:userId/updateFridgeSelection', async (req, res) => {
//   const { userId } = req.params;
//   const { fridgeSelection } = req.body;

//   try {
//     // Update the user document by adding a new array to the fridge matrix
//     const user = await User.findById(userId);
//     if (!user) {
//       return res.status(404).json({ message: 'User not found' });
//     }

//     // Add the new selection array to the user's fridgeSelectionMatrix
//     user.fridgeSelectionMatrix = user.fridgeSelectionMatrix || [];
//     user.fridgeSelectionMatrix.push(fridgeSelection);

//     await user.save();

//     res.status(200).json({ message: 'Fridge selection updated successfully', user });
//   } catch (error) {
//     console.error('Error updating fridge selection:', error);
//     res.status(500).json({ message: 'Failed to update fridge selection' });
//   }
// });
app.patch('/api/users/:prolificId/updateFridgeSelection', async (req, res) => {
  const { prolificId } = req.params;
  const { fridgeSelection } = req.body;

  try {
    // Find the user by their prolificId
    const user = await User.findOne({ prolificId });
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Add the new selection array to the user's fridgeSelectionMatrix
    user.fridgeSelectionMatrix = user.fridgeSelectionMatrix || [];
    user.fridgeSelectionMatrix.push(fridgeSelection);

    await user.save();

    res.status(200).json({ message: 'Fridge selection updated successfully', user });
  } catch (error) {
    console.error('Error updating fridge selection:', error);
    res.status(500).json({ message: 'Failed to update fridge selection' });
  }
});

// PATCH route to update user with survey data
app.patch('/api/users/updateform', async (req, res) => {
  const { prolificId, endTime, formData } = req.body;

  try {
    // Update the user by prolificId, adding formData to the user schema
    const user = await User.findOneAndUpdate(
      { prolificId },
      { endTime, formData },
      { new: true }
    );

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json({ message: 'User updated successfully', user });
  } catch (error) {
    console.error('Error updating user:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Route to update the shuffledFridges field of a user using prolificId
app.patch('/api/users/:prolificId/fridgeshuffle', async (req, res) => {
  const { prolificId } = req.params;
  const { shuffledFridges } = req.body;

  try {
    // Find the user and push the new shuffled fridges array into the shuffledFridges matrix
    const user = await User.findOneAndUpdate(
      { prolificId },
      { $push: { shuffledFridges } },
      { new: true }
    );

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json(user);
  } catch (error) {
    console.error('Error updating shuffledFridges:', error);
    res.status(500).json({ error: 'Failed to update shuffledFridges' });
  }
});

// API route to add a timestamp to startConditionClick
app.patch('/api/users/:prolificId/startcondition-click', async (req, res) => {
  const { prolificId } = req.params;
  const { timestamp } = req.body; // Expecting timestamp in the request body

  try {
    // Find the user by prolificId
    const user = await User.findOne({ prolificId });
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Add the provided timestamp to the comparisonClick array
    user.startConditionClick.push(new Date(timestamp));

    await user.save();

    res.status(200).json({ message: 'start condition click timestamp added successfully', user });
  } catch (error) {
    console.error('Error updating startConditionClick:', error);
    res.status(500).json({ message: 'Failed to update startConditionClick' });
  }
});

// API route to add a timestamp to comparisonClick
app.patch('/api/users/:prolificId/comparison-click', async (req, res) => {
  const { prolificId } = req.params;
  const { timestamp } = req.body; // Expecting timestamp in the request body

  try {
    // Find the user by prolificId
    const user = await User.findOne({ prolificId });
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Add the provided timestamp to the comparisonClick array
    user.comparisonClick.push(new Date(timestamp));

    await user.save();

    res.status(200).json({ message: 'Comparison click timestamp added successfully', user });
  } catch (error) {
    console.error('Error updating comparisonClick:', error);
    res.status(500).json({ message: 'Failed to update comparisonClick' });
  }
});

// API route to add a timestamp to selectFridgeClick
app.patch('/api/users/:prolificId/select-fridge-click', async (req, res) => {
  const { prolificId } = req.params;
  const { timestamp } = req.body; // Expecting timestamp in the request body

  try {
    // Find the user by prolificId
    const user = await User.findOne({ prolificId });
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Add the provided timestamp to the selectFridgeClick array
    user.selectFridgeClick.push(new Date(timestamp));

    await user.save();

    res.status(200).json({ message: 'Select fridge click timestamp added successfully', user });
  } catch (error) {
    console.error('Error updating selectFridgeClick:', error);
    res.status(500).json({ message: 'Failed to update selectFridgeClick' });
  }
});

// Route to download user data as CSV
app.get('/api/users/download', async (req, res) => {
  try {
    // Fetch all users from the database
    const users = await User.find();

    // Convert JSON to CSV
    const json2csvParser = new Parser();
    const csv = json2csvParser.parse(users);

    // Set the headers to indicate a file download
    res.header('Content-Type', 'text/csv');
    res.attachment('users.csv'); // Set the name of the downloaded file
    res.send(csv); // Send the CSV file
  } catch (error) {
    console.error('Error downloading user data:', error);
    res.status(500).json({ error: 'Failed to download user data' });
  }
});


//Fridge Schema
const fridgeSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true
    },
    nameId: {
        type: String
    },
    fridgeLogo: {
        type: String
    },
    fridgeImage: {
      type: String,
      required: true,
    },
    reviewImage: {
      type: String,
      required: true,
    },
    price: {
      type: Number,
      required: true,
    },
    dimensions: {
      height: { type: Number, required: true },
      width: { type: Number, required: true },
      depth: { type: Number, required: true },
    },
    coolingSpace: {
      type: Number,
      required: true,
    },
    freezerSpace: {
      type: Number,
      required: true,
    },
    totalSpace: {
      type: Number,
      required: true,
    },
    productWeight: {
      type: Number,
      required: true,
    },
    energyConsumption: {
      type: Number,
      required: true,
    },
    iceMaker: {
      type: Boolean,
      required: true,
    },
    garageReady: {
      type: Boolean,
      required: true,
    },
    internalWaterDispenser: {
      type: Boolean,
      required: true,
    },
    warranty: {
      type: String,
      required: true,
    },
  });

const Fridge = mongoose.model('Fridge', fridgeSchema);

app.get('/api/fridges', async (req, res) => {
    try {
      const fridges = await Fridge.find();
      res.status(200).json(fridges);
    } catch (error) {
      res.status(500).json({ message: 'Error retrieving fridges', error });
    }
  });

app.post('/api/fridges/create', async (req, res) => {
    const fridgeData = req.body;

    const newFridge = new Fridge({
        name: fridgeData.name,
        fridgeImage: fridgeData.fridgeImage,
        reviewImage: fridgeData.reviewImage,
        price: fridgeData.price,
        dimensions: {
        height: fridgeData.dimensions.height,
        width: fridgeData.dimensions.width,
        depth: fridgeData.dimensions.depth,
        },
        coolingSpace: fridgeData.coolingSpace,
        freezerSpace: fridgeData.freezerSpace,
        totalSpace: fridgeData.totalSpace,
        productWeight: fridgeData.productWeight,
        energyConsumption: fridgeData.energyConsumption,
        iceMaker: fridgeData.iceMaker,
        garageReady: fridgeData.garageReady,
        internalWaterDispenser: fridgeData.internalWaterDispenser,
        warranty: fridgeData.warranty,
    });

    try {
        const savedFridge = await newFridge.save();
        res.status(201).json(savedFridge);
    } catch (error) {
        res.status(400).json({ message: 'Error adding fridge', error });
    }
});

// Add a new endpoint to get specific fridges by name array
app.post('/api/fridges/compare', async (req, res) => {
    const { names } = req.body; // Expecting the names as an array in the request body
  
    if (!Array.isArray(names) || names.length === 0) {
      return res.status(400).json({ message: 'Fridge names must be a non-empty array' });
    }
  
    try {
      const fridges = await Fridge.find({ name: { $in: names } });
      res.status(200).json(fridges);
    } catch (error) {
      res.status(500).json({ message: 'Error retrieving fridges', error });
    }
  });
  

// Visit schema for tracking page visits
const visitSchema = new mongoose.Schema({
    page: String,
    count: { type: Number, default: 0 },
});

const Visit = mongoose.model('Visit', visitSchema);

// Initialize visit counters for each page if not already present
const initializeVisits = async () => {
    const pages = ['page1', 'page2', 'page3'];
    for (let page of pages) {
        const existingVisit = await Visit.findOne({ page });
        if (!existingVisit) {
            await Visit.create({ page });
        }
    }
};

initializeVisits();

// API endpoint to determine the route
app.get('/api/route', async (req, res) => {
    try {
        // Get the page with the minimum count
        const visit = await Visit.find().sort({ count: 1 }).limit(1);
        const selectedPage = visit[0];

        // Increment the count for the selected page
        await Visit.updateOne({ _id: selectedPage._id }, { $inc: { count: 1 } });

        res.json({ route: selectedPage.page });
    } catch (error) {
        console.error("Error determining the route", error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.listen(5000, () => {
    console.log('Server is running on port 5000');
});
